import struct
import numpy as np
import matplotlib.pyplot as plt
from PIL import Image
import os

def read_seed(start_byte,out_hex):
    """
    This function reads the coordinates and some attributes of __one__  seed in an image from a .tbin file generated by
    SmartGrain.

    Inputs:
        start_byte: The first byte to start reading for the current seed
        out_hex: The full raw hexadecimal file, containing all seeds.
    Output:
        seed: a dictionary containing the fields
        ["Centroid", "IS (intersection?)", "Length", "width", "Area", "PL", "Circularity", "Contour"]
        , where Contour contains the coordinates of the pixels at the contour of the seed.
        new_start: The byte to start reading the next seed.
    """
    vals = []
    line = out_hex[start_byte:start_byte+48]
    for i in range(len(line) // 4):
        hexval = "".join(line[i * 4:i * 4 + 4][::-1])
        decimal_val = struct.unpack("!l", bytes.fromhex(hexval))[0]
        vals.append(decimal_val)

    vals2 = np.reshape(vals, [6, 2])
    # Bytes 48 through  52 are zeroes.

    # Next are a bunch of properties of the seed as computed by SmartGrain, described below, and stored in attrib.
    # Attributes = ["Centroid", "IS (intersection?)", "Length", "width", "Area", "PL", "Circularity"]
    line = out_hex[start_byte+52:start_byte+52+100]
    attrib = []
    for i in range(len(line) // 8):
        hexval = "".join(line[i * 8:i * 8 + 8][::-1])
        decimal_val = struct.unpack("!d", bytes.fromhex(hexval))[0]
        attrib.append(decimal_val)

    # Read the number of points defining the outline of the seed.
    line = out_hex[start_byte+304:start_byte+308]
    for i in range(len(line) // 4):
        hexval = "".join(line[i * 4:i * 4 + 4][::-1])
        decimal_val = struct.unpack("!l", bytes.fromhex(hexval))[0]
        n_points = decimal_val

    # Read the coordinate of the seeds.
    line = out_hex[start_byte+308:start_byte+308 + ((n_points ) * 3 * 4)]
    coords = []
    for i in range((n_points) * 3):
        hexval = "".join(line[i * 4:i * 4 + 4][::-1])
        decimal_val = struct.unpack("!l", bytes.fromhex(hexval))[0]
        coords.append(decimal_val)

    coords2 = np.reshape(coords, [n_points, 3])

    # Compute at which byte to start reading the next seed in the image.
    new_start = start_byte+308 + ((n_points ) * 3 * 4)

    # Store the seed attributes as a dictionary.
    seed = {}
    seed["Centroid"] = np.array([attrib[0], attrib[1]])
    seed["Intersection"] = np.array([attrib[2], attrib[3]])
    seed["Length"] = np.array([attrib[4]])
    seed["Width"] = np.array([attrib[5]])
    seed["Area"] = np.array([attrib[6]])
    seed["PL"] = np.array([attrib[7]])
    seed["Circularity"] = np.array([attrib[8]])
    seed["Contour"] = coords2

    return  seed, new_start




def print_coordinates(seed_inds):
    
    b = 0

    annotations_folder = "C:/Users/alvin/Desktop/Object Detection/Mask-RCNN-TF2-master/annotations/"
    if not os.path.exists(annotations_folder):
        os.makedirs(annotations_folder)
    base_folder = "C:/Users/alvin/Desktop/Object Detection/Mask-RCNN-TF2-master/"
    jpg_base_folder = "C:/Users/alvin/Desktop/Object Detection/Mask-RCNN-TF2-master/all_images/"
    tbin_base_folder = "C:/Users/alvin/Desktop/Object Detection/Mask-RCNN-TF2-master/all_tbin/"

    jpg_files = []
    tbin_files = []

    jpg_files = [os.path.join(jpg_base_folder, file) for file in os.listdir(jpg_base_folder) if os.path.isfile(os.path.join(jpg_base_folder, file)) and file.lower().endswith('.jpg')]
    
    tbin_files = [os.path.join(tbin_base_folder, file) for file in os.listdir(tbin_base_folder) if os.path.isfile(os.path.join(tbin_base_folder, file)) and file.lower().endswith('.tbin')]
    
    

    for i in range(0, len(jpg_files)):
        xml_file_path = os.path.join(annotations_folder, f"{os.path.split(jpg_files[i])[-1]}.xml")

        start_byte = 120
        seeds = []

        try:
            with open(tbin_files[i], "rb") as f:
                buff = f.read()
            out_hex = ['{:02X}'.format(b) for b in buff]

            #while True:
            #while start_byte < len(out_hex):
            for _ in range(2):
                seed, start_byte = read_seed(start_byte=start_byte, out_hex=out_hex)
                seeds.append(seed)
                b += 1
                #print(f"Read seed no. {b}")
        except Exception as e:
            print(f"Error processing file {tbin_files[i]}: {e}")

        areas = []
        Circularities = []

        for seed in seeds:
            areas.append(seed["Area"])
            Circularities.append(seed["Circularity"])

        areas = np.array(areas)

        # Without being careful, SmartGrain can also segment other stuff,
        # e.g., parts of the ruler, or tiny specks which shouldn't be considered seeds.
        # The below line removes unreasonably large, and small values.
        # Real seeds seem to, __in this particular camera setup__, have reasonable seed areas vary between around 2000 - 5000
        seed_inds = np.where(np.all(np.hstack([np.array(areas) < 100000, np.array(areas) > 200]), axis=1))[0]

        seed_inds_for_writing = seed_inds

        #file = "C:/Users/alvin/Desktop/croptailor/oat_images/Additional data with labels/17-0014 LT17-CT0023-M7/IMG_8922.JPG"

        with Image.open(jpg_files[i]) as img:
            width, height = img.size
        #Create .xml file
        f = open(xml_file_path, "a")
        #Writes the first lines about folder, filename, path and source.
        f.write(f"<annotation>\n<folder>all_images</folder>\n<filename>{os.path.split(jpg_files[i])[-1]}</filename>\n<path>C:/Users/alvin/Desktop/Object Detection/Mask-RCNN-TF2-master/all_images</path>\n<source>\n<database>Unknown</database>\n</source>\n")
        #Writes size of image
        f.write(f"<size>\n<width>{width}</width>\n<height>{height}</height>\n<depth>3</depth>\n</size>\n<segmented>0</segmented>\n")

        # Print coordinates and plot only for seeds in seed_inds
        for idx, seed_idx in enumerate(seed_inds_for_writing, start=1):
            seed = seeds[seed_idx]
            #print(f"Seed {idx} Contour Coordinates:")
            #for coord in seed["Contour"]:
                #print(f"X: {coord[0]}, Y: {coord[1]}")
            #print("\n---\n")

            # Plot the seed contour
            x_coor = seed["Contour"][:, 0]
            y_coor = seed["Contour"][:, 1]

            maxmin = [min(x_coor), max(x_coor), min(y_coor), max(y_coor)]

            #Writes the xmin, xmax, ymin and ymax of a specific seed.
            f.write(f"<object>\n<name>seed</name>\n<pose>Unspecified</pose>\n<truncated>0</truncated>\n<difficult>0</difficult>\n<bndbox>\n<xmin>{maxmin[0]}</xmin>\n<ymin>{maxmin[2]}</ymin>\n<xmax>{maxmin[1]}</xmax>\n<ymax>{maxmin[3]}</ymax>\n</bndbox>\n</object>\n")

            #print(f"Min x: {maxmin[0]}, Max x: {maxmin[1]}, Min y: {maxmin[2]}, Max y: {maxmin[3]}")

        

        f.write(f"</annotation>")
        f.close()

# Provide the path to your specific tbin file
tbin_file_path = "C:/Users/alvin/Desktop/croptailor/oat_images/Additional data with labels/17-0014 LT17-CT0023-M7/$$IMG_8922.tbin"
seed_inds = []  # Add the indices of seeds you want to process
print_coordinates(seed_inds)