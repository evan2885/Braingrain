import os
import struct
import numpy as np
from PIL import Image
from PIL import Image, ImageDraw
import matplotlib.pyplot as plt
import seaborn as sns
import math
import statistics


#os.makedirs(destination_folder, exist_ok=True)

def read_seed(start_byte,out_hex):
    """
    This function reads the coordinates and some attributes of __one__  seed in an image from a .tbin file generated by
    SmartGrain.

    Inputs:
        start_byte: The first byte to start reading for the current seed
        out_hex: The full raw hexadecimal file, containing all seeds.
    Output:
        seed: a dictionary containing the fields
        ["Centroid", "IS (intersection?)", "Length", "width", "Area", "PL", "Circularity", "Contour"]
        , where Contour contains the coordinates of the pixels at the contour of the seed.
        new_start: The byte to start reading the next seed.
    """
    vals = []
    line = out_hex[start_byte:start_byte+48]
    for i in range(len(line) // 4):
        hexval = "".join(line[i * 4:i * 4 + 4][::-1])
        decimal_val = struct.unpack("!l", bytes.fromhex(hexval))[0]
        vals.append(decimal_val)

    vals2 = np.reshape(vals, [6, 2])
    # Bytes 48 through  52 are zeroes.

    # Next are a bunch of properties of the seed as computed by SmartGrain, described below, and stored in attrib.
    # Attributes = ["Centroid", "IS (intersection?)", "Length", "width", "Area", "PL", "Circularity"]
    line = out_hex[start_byte+52:start_byte+52+100]
    attrib = []
    for i in range(len(line) // 8):
        hexval = "".join(line[i * 8:i * 8 + 8][::-1])
        decimal_val = struct.unpack("!d", bytes.fromhex(hexval))[0]
        attrib.append(decimal_val)

    # Read the number of points defining the outline of the seed.
    line = out_hex[start_byte+304:start_byte+308]
    for i in range(len(line) // 4):
        hexval = "".join(line[i * 4:i * 4 + 4][::-1])
        decimal_val = struct.unpack("!l", bytes.fromhex(hexval))[0]
        n_points = decimal_val

    # Read the coordinate of the seeds.
    line = out_hex[start_byte+308:start_byte+308 + ((n_points ) * 3 * 4)]
    coords = []
    for i in range((n_points) * 3):
        hexval = "".join(line[i * 4:i * 4 + 4][::-1])
        decimal_val = struct.unpack("!l", bytes.fromhex(hexval))[0]
        coords.append(decimal_val)

    coords2 = np.reshape(coords, [n_points, 3])

    # Compute at which byte to start reading the next seed in the image.
    new_start = start_byte+308 + ((n_points ) * 3 * 4)

    # Store the seed attributes as a dictionary.
    seed = {}
    seed["Centroid"] = np.array([attrib[0], attrib[1]])
    seed["Intersection"] = np.array([attrib[2], attrib[3]])
    seed["Length"] = np.array([attrib[4]])
    seed["Width"] = np.array([attrib[5]])
    seed["Area"] = np.array([attrib[6]])
    seed["PL"] = np.array([attrib[7]])
    seed["Circularity"] = np.array([attrib[8]])
    seed["Contour"] = coords2

    return  seed, new_start

def extract_areas_from_tbin(file_path):
    seeds = []
    start_byte = 120

    try:
        with open(file_path, "rb") as f:
            buff = f.read()
        out_hex = ['{:02X}'.format(b) for b in buff]

        while True:
            seed, start_byte = read_seed(start_byte=start_byte, out_hex=out_hex)
            seeds.append(seed)
    except Exception as e:
        print(f"Error processing {file_path}: {e}")

    areas = [seed["Area"][0] for seed in seeds if seed["Area"] > 1]

    print("Number of masks:", len(seeds))
    print("Number of areas:", len(areas))

    #for idx, seed in enumerate(seeds):
        #print(f"Mask {idx + 1} - Area: {seed['Area']}")
    return areas


file_path = "C:/Users/alvin/Desktop/Object Detection/Mask-RCNN-TF2-master/all_tbin/$$IMG_8488.tbin"
areas_list = extract_areas_from_tbin(file_path)
areaz = [2899, 3093, 3258, 3543, 3108, 3090, 3264, 3527, 3219, 3246, 3018, 2831, 3013, 2984, 3375, 3472, 2754, 3103, 3336, 3332, 3505, 3319, 3411, 2994, 3146, 3012, 2943, 2613, 3170, 2641, 2896, 2723, 2059, 2580, 2796, 3141, 2544, 2700, 3246, 3341, 2686, 2982, 3090, 3181, 2548, 3180, 3484, 2210, 2929, 2831, 2820, 2487, 3300, 2759, 2315, 3194, 2882, 3145, 2536, 2621, 3475, 2875, 2559, 3143, 3255, 2977, 3058, 3653, 2685, 2939, 2941, 3008, 3039, 2718, 2916, 2277, 3476, 2878, 3221, 2846, 2280, 2402, 2670, 2449, 3209, 2556, 3072, 2566, 2711, 2636, 2993, 2426, 2290, 3254, 2799, 3121, 2668, 3006, 2342, 2715, 2640, 2929, 2587, 2592, 3413, 2926, 2353, 3107, 3043, 2362, 3132, 2639, 2856, 2686, 2860, 2913, 3535, 2205, 2958, 2987, 2722, 2863, 2762, 2627, 2871, 2583, 2682, 2449, 3108, 2707, 2857, 2267, 2933, 2239, 2622, 2752, 3142, 3134, 2977, 3258, 3083, 2591, 2512, 2925, 2340, 2325, 3423, 2429, 2026, 2792, 2309, 2483, 2962, 3402, 3162, 2774, 2296, 2171, 2540, 2283, 2578, 2528, 2363, 3166, 2803, 3736, 2962, 2100, 2647, 2284, 2740, 2337, 2551, 2741, 2752, 2048, 2871, 2373]

#print("List of Areas:", sorted(areas_list))

#print("Smartgrain: ", min(areas_list), max(areas_list))
#print("Our model: ", min(areaz), max(areaz))



plt.figure(figsize=(12, 6))

plt.subplot(1, 2, 1)
sns.kdeplot(areas_list, shade=True, color='blue')
plt.title('SmartGrain')
plt.xlabel('Seed area')
plt.ylabel('Frequency')

plt.subplot(1, 2, 2)

sns.kdeplot(areaz, shade=True, color='red')
plt.title('Our model')
plt.xlabel('Seed area')
plt.ylabel('Frequency')

plt.tight_layout()
plt.show()

